<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Probability Sea</title>
    <style>
        :root {
            --glass-bg: rgba(10, 15, 30, 0.6);
            --glass-border: rgba(255, 255, 255, 0.1);
            --accent: #00f3ff;
            --text: #e0e0e0;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Inter', system-ui, sans-serif;
            color: var(--text);
            user-select: none;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .ui-panel {
            position: absolute;
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 16px;
            pointer-events: auto;
            transition: opacity 0.3s;
        }

        #top-bar {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 24px;
            align-items: center;
            padding: 12px 24px;
        }

        #left-panel {
            top: 100px;
            left: 20px;
            width: 240px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        #right-panel {
            top: 100px;
            right: 20px;
            width: 200px;
        }

        #bottom-bar {
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
        }

        h1 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 1px;
            color: var(--accent);
            text-transform: uppercase;
        }

        .stat {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            opacity: 0.8;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-size: 12px;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
        }

        input[type="range"] {
            width: 100%;
            background: transparent;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--accent);
            margin-top: -6px;
            cursor: pointer;
            box-shadow: 0 0 10px var(--accent);
        }

        button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            color: var(--text);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: var(--accent);
        }

        button.active {
            background: var(--accent);
            color: #000;
            font-weight: bold;
        }

        .tooltip {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            animation: fadeOut 5s forwards;
            animation-delay: 2s;
            text-align: center;
            z-index: 100;
        }

        @keyframes fadeOut {
            0% {
                opacity: 1;
            }

            80% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        }
    </style>
</head>

<body>

    <canvas id="glcanvas"></canvas>

    <div id="top-bar" class="ui-panel">
        <h1>The Probability Sea</h1>
        <div class="stat" id="status-text">Ready</div>
    </div>

    <div id="left-panel" class="ui-panel">
        <div class="control-group">
            <label>Simulation Speed <span id="speed-val">5x</span></label>
            <input type="range" id="speed-slider" min="0" max="20" value="5">
        </div>
        <div class="control-group">
            <label>Packet Width (σ) <span id="width-val">1.5</span></label>
            <input type="range" id="width-slider" min="0.5" max="5.0" step="0.1" value="1.5">
        </div>
        <div class="control-group">
            <label>Brush Size <span id="brush-val">30</span></label>
            <input type="range" id="brush-slider" min="5" max="100" value="30">
        </div>
        <div class="control-group">
            <label>Potential Strength</label>
            <input type="range" id="pot-strength-slider" min="0" max="200" value="100">
        </div>
        <hr style="border-color: rgba(255,255,255,0.1); width: 100%;">
        <div class="control-group">
            <button id="toggle-phase" class="active">Show Phase</button>
            <button id="toggle-pot" class="active">Show Potential</button>
        </div>
    </div>

    <div id="bottom-bar" class="ui-panel">
        <button onclick="presets.clear()">Clear</button>
        <button onclick="presets.doubleSlit()">Double Slit</button>
        <button onclick="presets.harmonic()">Harmonic</button>
        <button onclick="presets.corral()">Corral</button>
        <button onclick="presets.tunnel()">Tunneling</button>
        <div style="width: 1px; background: rgba(255,255,255,0.2); margin: 0 8px;"></div>
        <button id="btn-pause">⏸ Pause</button>
        <button onclick="resetWave()">↺ Reset Wave</button>
    </div>

    <div class="tooltip">
        <h3>Controls</h3>
        <p>Left-drag: Draw Barriers | Shift+drag: Draw Wells</p>
        <p>Right-drag: Launch Wave Packet</p>
        <p>Scroll: Adjust Brush Size</p>
    </div>

    <!-- SHADERS -->
    <script id="vs" type="x-shader/x-vertex">
    #version 300 es
    in vec4 position;
    void main() {
        gl_Position = position;
    }
</script>

    <script id="fs-sim" type="x-shader/x-fragment">
    #version 300 es
    precision highp float;
    
    uniform sampler2D u_wave;
    uniform sampler2D u_potential;
    uniform vec2 u_res;
    uniform float u_dt;
    uniform int u_step; // 0 = update Real, 1 = update Imag
    
    out vec4 fragColor;
    
    vec2 laplacian(vec2 uv) {
        vec2 dx = vec2(1.0/u_res.x, 0.0);
        vec2 dy = vec2(0.0, 1.0/u_res.y);
        
        vec4 c = texture(u_wave, uv);
        vec4 l = texture(u_wave, uv - dx);
        vec4 r = texture(u_wave, uv + dx);
        vec4 d = texture(u_wave, uv - dy);
        vec4 u = texture(u_wave, uv + dy);
        
        return l.xy + r.xy + d.xy + u.xy - 4.0 * c.xy;
    }
    
    void main() {
        vec2 uv = gl_FragCoord.xy / u_res;
        vec4 wave = texture(u_wave, uv);
        float V = texture(u_potential, uv).r;
        
        vec2 lap = laplacian(uv);
        
        if (u_step == 0) {
            // Update Real
            float dR = -0.5 * lap.y + V * wave.y;
            // Damping at edges to prevent reflection artifacts (Absorbing Boundary)
            float dist = distance(uv, vec2(0.5));
            float damping = smoothstep(0.45, 0.5, dist);
            float val = wave.x + u_dt * dR;
            val *= (1.0 - damping * 0.1); 
            fragColor = vec4(val, wave.y, 0.0, 1.0);
        } else {
            // Update Imag
            float dI =  0.5 * lap.x - V * wave.x;
            float dist = distance(uv, vec2(0.5));
            float damping = smoothstep(0.45, 0.5, dist);
            float val = wave.y + u_dt * dI;
            val *= (1.0 - damping * 0.1);
            fragColor = vec4(wave.x, val, 0.0, 1.0);
        }
    }
</script>

    <script id="fs-launch" type="x-shader/x-fragment">
    #version 300 es
    precision highp float;
    
    uniform sampler2D u_wave;
    uniform vec2 u_res;
    uniform vec2 u_pos; // Mouse pos in pixels
    uniform vec2 u_mom; // Momentum vector
    uniform float u_sigma;
    
    out vec4 fragColor;
    
    void main() {
        vec2 uv = gl_FragCoord.xy / u_res;
        vec4 current = texture(u_wave, uv);
        
        vec2 coord = gl_FragCoord.xy;
        float dist = distance(coord, u_pos);
        
        // Gaussian envelope
        float env = exp(-dist*dist / (2.0 * u_sigma * u_sigma));
        
        // Plane wave phase
        float phase = dot(u_mom, coord - u_pos) * 0.2; // Scale factor for momentum sensitivity
        
        vec2 packet = vec2(cos(phase), sin(phase)) * env;
        
        // Add to current wave
        fragColor = vec4(current.xy + packet, 0.0, 1.0);
    }
</script>

    <script id="fs-pot" type="x-shader/x-fragment">
    #version 300 es
    precision highp float;
    
    uniform sampler2D u_potential;
    uniform vec2 u_res;
    uniform vec2 u_mouse;
    uniform float u_radius;
    uniform float u_val;
    uniform int u_mode; // 0 = none, 1 = draw
    
    out vec4 fragColor;
    
    void main() {
        vec2 uv = gl_FragCoord.xy / u_res;
        float current = texture(u_potential, uv).r;
        
        if (u_mode == 1) {
            float dist = distance(gl_FragCoord.xy, u_mouse);
            float brush = smoothstep(u_radius, u_radius * 0.5, dist);
            current = mix(current, u_val, brush * 0.5);
        }
        
        fragColor = vec4(current, 0.0, 0.0, 1.0);
    }
</script>

    <script id="fs-render" type="x-shader/x-fragment">
    #version 300 es
    precision highp float;
    
    uniform sampler2D u_wave;
    uniform sampler2D u_potential;
    uniform vec2 u_res;
    uniform float u_showPhase;
    uniform float u_showPot;
    
    // Drag visualization
    uniform vec2 u_dragStart;
    uniform vec2 u_dragEnd;
    uniform float u_isDragging;
    
    out vec4 fragColor;
    
    vec3 hsl2rgb(vec3 c) {
        vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);
        return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
    }
    
    float segment(vec2 p, vec2 a, vec2 b, float w) {
        vec2 pa = p - a, ba = b - a;
        float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
        return length(pa - ba * h) - w;
    }
    
    void main() {
        vec2 uv = gl_FragCoord.xy / u_res;
        vec4 wave = texture(u_wave, uv);
        float V = texture(u_potential, uv).r;
        
        float prob = dot(wave.xy, wave.xy);
        float amp = sqrt(prob);
        
        float phase = atan(wave.y, wave.x);
        float hue = (phase / 6.28318) + 0.5;
        
        vec3 color = vec3(0.0);
        vec3 fluidColor = vec3(0.05, 0.1, 0.3) * amp * 2.0;
        vec3 phaseColor = hsl2rgb(vec3(hue, 0.8, 0.5));
        
        if (u_showPhase > 0.5) {
            color += phaseColor * amp * 2.0;
        } else {
            color += vec3(0.1, 0.4, 1.0) * amp * 3.0;
        }
        
        float glow = pow(amp, 3.0) * 5.0;
        color += vec3(0.6, 0.9, 1.0) * glow;
        
        if (u_showPot > 0.5) {
            if (V > 0.1) {
                color += vec3(1.0, 0.2, 0.0) * V * 0.05;
                float grid = step(0.95, fract(uv.x * 50.0)) + step(0.95, fract(uv.y * 50.0));
                color += vec3(1.0, 0.5, 0.0) * grid * V * 0.02;
            } else if (V < -0.1) {
                color += vec3(0.5, 0.0, 1.0) * abs(V) * 0.05;
            }
        }
        
        // Draw Drag Arrow
        if (u_isDragging > 0.5) {
            float d = segment(gl_FragCoord.xy, u_dragStart, u_dragEnd, 2.0);
            if (d < 0.0) {
                color = vec3(1.0, 1.0, 1.0);
            }
        }
        
        fragColor = vec4(color, 1.0);
    }
</script>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl2', { antialias: false });

        if (!gl) {
            alert("WebGL 2.0 not supported. Please use a modern browser.");
        }

        gl.getExtension('EXT_color_buffer_float');
        gl.getExtension('OES_texture_float_linear');

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function createTexture(w, h) {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RG32F, w, h, 0, gl.RG, gl.FLOAT, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            return tex;
        }

        function createPotTexture(w, h) {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, w, h, 0, gl.RED, gl.FLOAT, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            return tex;
        }

        const SIM_RES = 512;
        let width, height;

        const vsSource = document.getElementById('vs').text.trim();
        const progSim = createProgram(gl, vsSource, document.getElementById('fs-sim').text.trim());
        const progPot = createProgram(gl, vsSource, document.getElementById('fs-pot').text.trim());
        const progLaunch = createProgram(gl, vsSource, document.getElementById('fs-launch').text.trim());
        const progRender = createProgram(gl, vsSource, document.getElementById('fs-render').text.trim());

        const quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

        let texWaveA = createTexture(SIM_RES, SIM_RES);
        let texWaveB = createTexture(SIM_RES, SIM_RES);
        let texPotA = createPotTexture(SIM_RES, SIM_RES);
        let texPotB = createPotTexture(SIM_RES, SIM_RES);

        const fbo = gl.createFramebuffer();

        let params = {
            dt: 0.2,
            speed: 5,
            width: 15.0, // Sigma in pixels
            brushSize: 30,
            potStrength: 100,
            paused: false,
            showPhase: true,
            showPot: true
        };

        let mouse = { x: 0, y: 0, down: false, rightDown: false, shift: false, dragStart: { x: 0, y: 0 } };

        function initWavePacket() {
            const data = new Float32Array(SIM_RES * SIM_RES * 2);
            const cx = SIM_RES / 2;
            const cy = SIM_RES / 2;
            const sigma = 20.0;
            const kx = 1.0;

            for (let y = 0; y < SIM_RES; y++) {
                for (let x = 0; x < SIM_RES; x++) {
                    let dx = x - cx;
                    let dy = y - cy;
                    let r2 = dx * dx + dy * dy;
                    let env = Math.exp(-r2 / (2 * sigma * sigma));
                    let phase = kx * dx * 0.1;
                    let idx = (y * SIM_RES + x) * 2;
                    data[idx] = env * Math.cos(phase);
                    data[idx + 1] = env * Math.sin(phase);
                }
            }
            gl.bindTexture(gl.TEXTURE_2D, texWaveA);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, SIM_RES, SIM_RES, gl.RG, gl.FLOAT, data);
            gl.bindTexture(gl.TEXTURE_2D, texWaveB);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, SIM_RES, SIM_RES, gl.RG, gl.FLOAT, data);
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();
        initWavePacket();

        function runSimStep(stepType) {
            gl.useProgram(progSim);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

            let input = (stepType % 2 === 0) ? texWaveA : texWaveB;
            let output = (stepType % 2 === 0) ? texWaveB : texWaveA;

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, output, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, input);
            gl.uniform1i(gl.getUniformLocation(progSim, "u_wave"), 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, texPotA);
            gl.uniform1i(gl.getUniformLocation(progSim, "u_potential"), 1);

            gl.uniform2f(gl.getUniformLocation(progSim, "u_res"), SIM_RES, SIM_RES);
            gl.uniform1f(gl.getUniformLocation(progSim, "u_dt"), params.dt);
            gl.uniform1i(gl.getUniformLocation(progSim, "u_step"), stepType % 2);

            gl.viewport(0, 0, SIM_RES, SIM_RES);
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        function updatePotential() {
            if (mouse.down && !mouse.rightDown) {
                gl.useProgram(progPot);
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texPotB, 0);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texPotA);
                gl.uniform1i(gl.getUniformLocation(progPot, "u_potential"), 0);

                gl.uniform2f(gl.getUniformLocation(progPot, "u_res"), SIM_RES, SIM_RES);

                let mx = (mouse.x / width) * SIM_RES;
                let my = (1.0 - mouse.y / height) * SIM_RES;
                gl.uniform2f(gl.getUniformLocation(progPot, "u_mouse"), mx, my);

                gl.uniform1f(gl.getUniformLocation(progPot, "u_radius"), params.brushSize);

                let val = params.potStrength * (mouse.shift ? -1.0 : 1.0);
                gl.uniform1f(gl.getUniformLocation(progPot, "u_val"), val);
                gl.uniform1i(gl.getUniformLocation(progPot, "u_mode"), 1);

                gl.viewport(0, 0, SIM_RES, SIM_RES);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                let temp = texPotA;
                texPotA = texPotB;
                texPotB = temp;
            }
        }

        function launchPacket() {
            // Launch packet into texWaveA
            gl.useProgram(progLaunch);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texWaveB, 0); // Write to B

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texWaveA); // Read from A
            gl.uniform1i(gl.getUniformLocation(progLaunch, "u_wave"), 0);

            gl.uniform2f(gl.getUniformLocation(progLaunch, "u_res"), SIM_RES, SIM_RES);

            let mx = (mouse.dragStart.x / width) * SIM_RES;
            let my = (1.0 - mouse.dragStart.y / height) * SIM_RES;
            gl.uniform2f(gl.getUniformLocation(progLaunch, "u_pos"), mx, my);

            let dx = (mouse.x - mouse.dragStart.x);
            let dy = -(mouse.y - mouse.dragStart.y); // Flip Y
            gl.uniform2f(gl.getUniformLocation(progLaunch, "u_mom"), dx * 0.05, dy * 0.05);

            gl.uniform1f(gl.getUniformLocation(progLaunch, "u_sigma"), params.width);

            gl.viewport(0, 0, SIM_RES, SIM_RES);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // Swap
            let temp = texWaveA;
            texWaveA = texWaveB;
            texWaveB = temp;
        }

        function render() {
            if (!params.paused) {
                for (let i = 0; i < params.speed; i++) {
                    runSimStep(0);
                    runSimStep(1);
                }
            }

            updatePotential();

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, width, height);
            gl.useProgram(progRender);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texWaveA);
            gl.uniform1i(gl.getUniformLocation(progRender, "u_wave"), 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, texPotA);
            gl.uniform1i(gl.getUniformLocation(progRender, "u_potential"), 1);

            gl.uniform2f(gl.getUniformLocation(progRender, "u_res"), width, height);
            gl.uniform1f(gl.getUniformLocation(progRender, "u_showPhase"), params.showPhase ? 1.0 : 0.0);
            gl.uniform1f(gl.getUniformLocation(progRender, "u_showPot"), params.showPot ? 1.0 : 0.0);

            gl.uniform2f(gl.getUniformLocation(progRender, "u_dragStart"), mouse.dragStart.x, height - mouse.dragStart.y);
            gl.uniform2f(gl.getUniformLocation(progRender, "u_dragEnd"), mouse.x, height - mouse.y);
            gl.uniform1f(gl.getUniformLocation(progRender, "u_isDragging"), mouse.rightDown ? 1.0 : 0.0);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        canvas.addEventListener('mousedown', e => {
            if (e.button === 2) {
                mouse.rightDown = true;
                mouse.dragStart.x = e.clientX;
                mouse.dragStart.y = e.clientY;
            } else {
                mouse.down = true;
            }
        });
        window.addEventListener('mouseup', e => {
            if (mouse.rightDown) {
                launchPacket();
            }
            mouse.down = false;
            mouse.rightDown = false;
        });
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        window.addEventListener('keydown', e => {
            if (e.key === 'Shift') mouse.shift = true;
        });
        window.addEventListener('keyup', e => {
            if (e.key === 'Shift') mouse.shift = false;
        });
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        document.getElementById('speed-slider').oninput = function () {
            params.speed = parseInt(this.value);
            document.getElementById('speed-val').innerText = this.value + 'x';
        };
        document.getElementById('width-slider').oninput = function () {
            params.width = parseFloat(this.value) * 10.0; // Scale for pixel units
            document.getElementById('width-val').innerText = this.value;
        };
        document.getElementById('brush-slider').oninput = function () {
            params.brushSize = parseFloat(this.value);
            document.getElementById('brush-val').innerText = this.value;
        };
        document.getElementById('pot-strength-slider').oninput = function () {
            params.potStrength = parseFloat(this.value);
        };
        document.getElementById('btn-pause').onclick = function () {
            params.paused = !params.paused;
            this.innerText = params.paused ? "▶ Play" : "⏸ Pause";
        };
        document.getElementById('toggle-phase').onclick = function () {
            params.showPhase = !params.showPhase;
            this.classList.toggle('active');
        };
        document.getElementById('toggle-pot').onclick = function () {
            params.showPot = !params.showPot;
            this.classList.toggle('active');
        };

        window.resetWave = function () {
            initWavePacket();
        };

        window.presets = {
            clear: function () {
                const data = new Float32Array(SIM_RES * SIM_RES);
                gl.bindTexture(gl.TEXTURE_2D, texPotA);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, SIM_RES, SIM_RES, gl.RED, gl.FLOAT, data);
                gl.bindTexture(gl.TEXTURE_2D, texPotB);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, SIM_RES, SIM_RES, gl.RED, gl.FLOAT, data);
            },
            doubleSlit: function () {
                this.clear();
                const data = new Float32Array(SIM_RES * SIM_RES);
                const mid = Math.floor(SIM_RES / 2);
                for (let y = 0; y < SIM_RES; y++) {
                    for (let x = 0; x < SIM_RES; x++) {
                        if (Math.abs(x - (mid + 50)) < 5) {
                            if (Math.abs(y - mid) < 10 || Math.abs(y - (mid + 40)) < 5 || Math.abs(y - (mid - 40)) < 5) {
                            } else {
                                data[y * SIM_RES + x] = 200.0;
                            }
                        }
                    }
                }
                gl.bindTexture(gl.TEXTURE_2D, texPotA);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, SIM_RES, SIM_RES, gl.RED, gl.FLOAT, data);
            },
            harmonic: function () {
                const data = new Float32Array(SIM_RES * SIM_RES);
                const mid = SIM_RES / 2;
                for (let y = 0; y < SIM_RES; y++) {
                    for (let x = 0; x < SIM_RES; x++) {
                        let dx = x - mid;
                        let dy = y - mid;
                        let r2 = dx * dx + dy * dy;
                        data[y * SIM_RES + x] = r2 * 0.005;
                    }
                }
                gl.bindTexture(gl.TEXTURE_2D, texPotA);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, SIM_RES, SIM_RES, gl.RED, gl.FLOAT, data);
            },
            corral: function () {
                const data = new Float32Array(SIM_RES * SIM_RES);
                const mid = SIM_RES / 2;
                const radius = 100;
                for (let y = 0; y < SIM_RES; y++) {
                    for (let x = 0; x < SIM_RES; x++) {
                        let dx = x - mid;
                        let dy = y - mid;
                        let r = Math.sqrt(dx * dx + dy * dy);
                        if (r > radius && r < radius + 10) {
                            data[y * SIM_RES + x] = 200.0;
                        }
                    }
                }
                gl.bindTexture(gl.TEXTURE_2D, texPotA);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, SIM_RES, SIM_RES, gl.RED, gl.FLOAT, data);
            },
            tunnel: function () {
                this.clear();
                const data = new Float32Array(SIM_RES * SIM_RES);
                const mid = Math.floor(SIM_RES / 2);
                for (let y = 0; y < SIM_RES; y++) {
                    for (let x = 0; x < SIM_RES; x++) {
                        if (Math.abs(x - (mid + 50)) < 3) {
                            data[y * SIM_RES + x] = 50.0;
                        }
                    }
                }
                gl.bindTexture(gl.TEXTURE_2D, texPotA);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, SIM_RES, SIM_RES, gl.RED, gl.FLOAT, data);
            }
        };

        requestAnimationFrame(render);

    </script>
</body>

</html>
